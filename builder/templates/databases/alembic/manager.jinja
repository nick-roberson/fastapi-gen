""" Template for alembic model manager, includes the following endpoints:
- create_model
- create_models
- get_model
- get_models
- update_model
- delete_model
"""

import logging

from datetime import datetime
from typing import List

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from db.constants import DB_URL
from models.models import {{ model.name }}, {{ model.name }}Query
from db.models import DB{{ model.name }}


# Singleton Manager for {{ model.name }}
__{{ model.name.upper()}}_MANAGER = None
def get_{{ model.name.lower() }}_manager():
    global __{{ model.name.upper()}}_MANAGER
    if not __{{ model.name.upper()}}_MANAGER:
        __{{ model.name.upper()}}_MANAGER = {{ model.name }}Manager()
    return __{{ model.name.upper()}}_MANAGER


class {{ model.name }}Manager:
    """{{ model.name }} manager to handle all database operations for the {{ model.name }} records."""

    def __init__(self):
        """Initialize the CaseManager."""
        engine = create_engine(DB_URL)
        self.session_factory = sessionmaker(bind=engine)
        logging.info("CaseManager successfully initialized")

    def get(self, id: int) -> {{ model.name }}:
        """Retrieve a {{ model.name }} record from the database by its ID."""
        logging.info(f"Retrieving {{ model.name }} record with ID: {id}")
        try:
            with self.session_factory() as session:

                # Retrieve the {{ model.name }} record by its ID
                item = session.query(DB{{ model.name }}).get(id)
                if not item:
                    return None

                # Return the {{ model.name }} record
                logging.info(f"Successfully retrieved {{ model.name }} record: {item}")
                return {{ model.name }}.from_orm(item)

        except Exception as e:
            logging.error(f"Failed to retrieve {{ model.name }} record: {e}")
            raise e
        finally:
            self.close_session()

    def get_many(self, ids: List[int]) -> List[{{ model.name }}]:
        """Retrieve multiple {{ model.name }} records from the database by their IDs."""
        logging.info(f"Retrieving multiple {{ model.name }} records with IDs: {ids}")
        try:
            with self.session_factory() as session:

                # Retrieve the {{ model.name }} records by their IDs
                items = session.query(DB{{ model.name }}).filter(DB{{ model.name }}.id.in_(ids)).all()
                if not items:
                    return []

                # Return the {{ model.name }} records
                logging.info(f"Successfully retrieved multiple {{ model.name }} records: {items}")
                return [{{ model.name }}.from_orm(item) for item in items]

        except Exception as e:
            logging.error(f"Failed to retrieve multiple {{ model.name }} records: {e}")
            raise e
        finally:
            self.close_session()

    def get_all(self) -> List[{{ model.name }}]:
        """Retrieve all {{ model.name }} records from the database."""
        logging.info("Retrieving all {{ model.name }} records")
        try:
            with self.session_factory() as session:

                # Retrieve all {{ model.name }} records
                items = session.query(DB{{ model.name }}).all()
                if not items:
                    return []

                # Return the {{ model.name }} records
                logging.info(f"Successfully retrieved all {{ model.name }} records: {items}")
                return [{{ model.name }}.from_orm(item) for item in items]

        except Exception as e:
            logging.error(f"Failed to retrieve all {{ model.name }} records: {e}")
            raise e
        finally:
            self.close_session()

    def query(self, query: {{ model.name }}Query) -> List[{{ model.name }}]:
        """Query the {{ model.name }} records from the database."""
        logging.info(f"Querying {{ model.name }} records: {query}")
        try:
            with self.session_factory() as session:

                # Build the query
                query_builder = session.query(DB{{ model.name }})
                for key, value in query.dict().items():
                    if value is not None:
                        query_builder = query_builder.filter(getattr(DB{{ model.name }}, key) == value)

                # Execute the query
                items = query_builder.all()
                if not items:
                    return []

                # Return the {{ model.name }} records
                logging.info(f"Successfully queried {{ model.name }} records: {items}")
                return [{{ model.name }}.from_orm(item) for item in items]

        except Exception as e:
            logging.error(f"Failed to query {{ model.name }} records: {e}")
            raise e
        finally:
            self.close_session()

    def create(self, data: {{ model.name }}) -> {{ model.name }}:
        """Create a new {{ model.name }} record in the database."""
        logging.info(f"Creating new {{ model.name }} record: {data}")
        try:
            with self.session_factory() as session:

                # Create a new {{ model.name }} record
                new_item = DB{{ model.name }}(**data.dict())

                # Clear the id of the new model to ensure it is created as a new record
                new_item.id = None

                # Add the new {{ model.name }} record to the session and commit
                session.add(new_item)
                session.commit()

                # Refresh and return the new {{ model.name }} record
                session.refresh(new_item)
                logging.info(f"Successfully created new {{ model.name }} record: {new_item}")
                return {{ model.name }}.from_orm(new_item)

        except Exception as e:
            logging.error(f"Failed to create new {{ model.name }} record: {e}")
            raise e
        finally:
            self.close_session()

    def create_many(self, data: List[{{ model.name }}]) -> List[{{ model.name }}]:
        """Create multiple new {{ model.name }} records in the database."""
        logging.info(f"Creating multiple new {{ model.name }} records: {data}")
        try:
            with self.session_factory() as session:

                # Create new {{ model.name }} records
                new_items = [DB{{ model.name }}(**item.dict()) for item in data]

                # Clear the ids of the new models to ensure they are created as new records
                for item in new_items:
                    item.id = None

                # Add the new {{ model.name }} records to the session and commit
                session.add_all(new_items)
                session.commit()

                # Refresh and return the new {{ model.name }} records
                for item in new_items:
                    session.refresh(item)
                logging.info(f"Successfully created multiple new {{ model.name }} records: {new_items}")
                return [{{ model.name }}.from_orm(item) for item in new_items]

        except Exception as e:
            logging.error(f"Failed to create multiple new {{ model.name }} records: {e}")
            raise e
        finally:
            self.close_session()

    def update(self, data: {{ model.name }}) -> {{ model.name }}:
        """Update an existing {{ model.name }} record in the database."""
        logging.info(f"Updating {{ model.name }} record with ID {id}: {data}")
        try:
            with self.session_factory() as session:

                # If id is not present on update, raise an exception
                if not data.id:
                    raise Exception("ID is required to update {{ model.name }} record")

                # Retrieve the {{ model.name }} record by its ID
                item = session.query(DB{{ model.name }}).get(data.id)
                if not item:
                    raise Exception("{{ model.name }} record does not exist")

                # Update the {{ model.name }} record with the new data
                for key, value in data.dict().items():
                    setattr(item, key, value)
                item.updated_at = datetime.now()

                # Commit the changes
                session.commit()

                # Refresh and return the updated {{ model.name }} record
                session.refresh(item)
                logging.info(f"Successfully updated {{ model.name }} record: {item}")
                return {{ model.name }}.from_orm(item)

        except Exception as e:
            logging.error(f"Failed to update {{ model.name }} record: {e}")
            raise e
        finally:
            self.close_session()

    def update_many(self, data: List[{{ model.name }}]) -> List[{{ model.name }}]:
        """Update multiple existing {{ model.name }} records in the database."""
        logging.info(f"Updating multiple {{ model.name }} records: {data}")
        try:
            with self.session_factory() as session:
                # Update the {{ model.name }} records with the new data
                updated_items = []

                # Get all the items by id, raise exception if any are missing
                model_ids = [item.id for item in data]
                items = session.query(DB{{ model.name }}).filter(DB{{ model.name }}.id.in_(model_ids)).all()
                if len(items) != len(model_ids):
                    raise Exception("Some {{ model.name }} records do not exist")

                item_map = {item.id: item for item in items}
                update_map = {item.id: item for item in data}

                # Update the items with the new data
                for id, item in item_map.items():
                    new_update = update_map[id]
                    for key, value in new_update.dict().items():
                        setattr(item, key, value)
                    item.updated_at = datetime.now()
                    updated_items.append(item)

                # Commit the changes
                session.commit()

                # Refresh and return the updated {{ model.name }} records
                for item in updated_items:
                    session.refresh(item)

                # Return the updated items
                logging.info(f"Successfully updated multiple {{ model.name }} records: {updated_items}")
                return [{{ model.name }}.from_orm(item) for item in updated_items]

        except Exception as e:
            logging.error(f"Failed to update multiple {{ model.name }} records: {e}")
            raise e
        finally:
            self.close_session()


    def delete(self, id: int) -> {{ model.name }}:
        """Delete a {{ model.name }} record from the database by its ID."""
        logging.info(f"Deleting {{ model.name }} record with ID: {id}")
        try:
            with self.session_factory() as session:

                # Retrieve the {{ model.name }} record by its ID
                item = session.query(DB{{ model.name }}).get(id)
                if not item:
                    raise Exception("{{ model.name }} record does not exist")

                # Delete the {{ model.name }} record
                session.delete(item)
                session.commit()

                # Return the deleted {{ model.name }} record
                logging.info(f"Successfully deleted {{ model.name }} record: {item}")
                return {{ model.name }}.from_orm(item)

        except Exception as e:
            logging.error(f"Failed to delete {{ model.name }} record: {e}")
            raise e
        finally:
            self.close_session()

    def delete_many(self, ids: List[int]) -> List[{{ model.name }}]:
        """Delete multiple {{ model.name }} records from the database by their IDs."""
        logging.info(f"Deleting multiple {{ model.name }} records with IDs: {ids}")
        try:
            with self.session_factory() as session:

                # Retrieve the {{ model.name }} records by their IDs
                items = session.query(DB{{ model.name }}).filter(DB{{ model.name }}.id.in_(ids)).all()
                if len(items) != len(ids):
                    raise Exception("Some {{ model.name }} records do not exist")

                # Delete the {{ model.name }} records
                for item in items:
                    session.delete(item)

                # Commit the changes
                session.commit()

                # Return the deleted {{ model.name }} records
                logging.info(f"Successfully deleted multiple {{ model.name }} records: {items}")
                return [{{ model.name }}.from_orm(item) for item in items]

        except Exception as e:
            logging.error(f"Failed to delete multiple {{ model.name }} records: {e}")
            raise e
        finally:
            self.close_session()

    def close_session(self):
        """This method is now redundant since each action opens and closes its session."""
        pass
